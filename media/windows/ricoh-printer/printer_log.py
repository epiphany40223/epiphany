#!/user/bin/env python3

# Script which runs daily to update staff print totals
# based on csvs generated by the printer itself.

import os
import sqlite3
from sqlite3 import Error

import argparse
import datetime

import openpyxl
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment
from openpyxl.utils import get_column_letter

# Find the path to the ECC module (by finding the root of the git
# tree).  This is robust, but it's a little clunky. :-\
try:
    import sys
    import subprocess
    out = subprocess.run(['git', 'rev-parse', '--show-toplevel'],
                         capture_output=True)
    dirname = out.stdout.decode('utf-8').strip()
    if not dirname:
        raise Exception("Could not find git root.  Are you outside the git tree?")

    moddir  = os.path.join(dirname, 'python')
    sys.path.insert(0, moddir)
    import ECC
except Exception as e:
    sys.stderr.write("=== ERROR: Could not find common ECC Python module directory\n")
    sys.stderr.write(f"{e}\n")
    exit(1)

###########################################################

def setup_cli_args():
    parser = argparse.ArgumentParser(description='Import Ricoh data into an SQLite3 database.')
    parser.add_argument('--xlsx',
                        default='.\printlog.xlsx',
                        help='Path to xlsx file to write the data to')
    parser.add_argument('--db',
                        required=True,
                        help='Path to sqlite database to import values from')
    parser.add_argument('--timestamp1',
                        required=True,
                        help='First timestamp GMT "yyyy-mm-dd hh:mm:ss" to compare')
    parser.add_argument('--timestamp2',
                        required=True,
                        help='Second timestamp GMT "yyyy-mm-dd hh:mm:ss" to compare')

    parser.add_argument('--logfile',
                        default=None,
                        help='Optional output logfile')

    parser.add_argument('--slack-token-filename',
                        required=False, #TODO: switch back to True after debugging
                        help='File containing the Slack bot authorization token')

    parser.add_argument('--verbose',
                        default=False,
                        action='store_true',
                        help='Enable verbose output')
    parser.add_argument('--debug',
                        default=False,
                        action='store_true',
                        help='Enable extra debugging')

    args = parser.parse_args()

    return args

# returns a list of rows with with a timestamp matching the one passed to it
def fetch_timestamp_data(log, conn, timestamp):
    c = conn.cursor()

    c.execute('SELECT * FROM printlog WHERE timestamp=?', [timestamp])
    rows = c.fetchall()

    log.debug(f"Found {len(rows)} rows with timestamp {timestamp}")

    return rows


# returns a dictionary of staffers with their data
def extract_data_to_compare(log, rows, timestamp):

    staffers = dict()

    # iterates through the list of rows, retrieves data about each staffer
    for row in rows:
        num = row['department']
        staffers[num] = row

    log.debug(f"Extracted {len(staffers)} staffers with timestamp {timestamp}")
    return staffers


# finds the deltas between the sets of data, returns a list of users' deltas
def compare_timestamps(log, new_data, old_data):

    updated_printlog = list()

    for num, row in new_data.items():
        if num not in old_data:
            continue

        row_old = old_data[num]
        delta = {
            'department'   : row['department'],
            'name'         : row['name'],
        }
        for col in row.keys():
            # does not compare any data that is not an integer
            if type(row[col]) == str and type(row_old[col]) == str:
                continue
            delta[col] = row[col] - row_old[col]
        updated_printlog.append(delta)

    log.info(f'Compared {len(new_data)} staffers')
    return updated_printlog


# writes the new deltas to an xlsx
def write_to_xlsx(log, printlog, filename, timestamp1, timestamp2):
    wb = Workbook()
    ws = wb.active

    # adds row of headers, then writes each staffer's data to a row
    ws.append(list(printlog[0]))
    for staffer in printlog:
        ws.append(list(staffer.values()))

    # automatically adjusts the width of every column to fit the data in it
    dims = {}

    for row in ws.rows:
        for cell in row:
            if cell.value:
                dims[cell.column_letter] = max((dims.get(cell.column_letter, 0), len(str(cell.value))))+.5
    for col, value in dims.items():
        ws.column_dimensions[col].width = value

    # Title rows
    title_font = Font(color='FAFAF9')
    title_fill = PatternFill(fgColor='228B22', fill_type='solid')
    title_align = Alignment(horizontal='center')

    for cell in ws[1]:
        if cell.value:
            ws[cell.coordinate].fill = title_fill
            ws[cell.coordinate].font = title_font
    last_cell = cell.coordinate
    ws.insert_rows(1)
    ws.merge_cells(f'A1:{last_cell}')
    ws['A1'] = f'Comparing timestamps {timestamp1} and {timestamp2}'
    ws['A1'].fill = title_fill
    ws['A1'].font = title_font

    wb.save(filename)
    log.info(f"Wrote {filename} with {len(printlog)} data rows")


def open_db(log, filename):
    # If the database exists, just open and return it
    if os.path.exists(filename):
        conn = sqlite3.connect(filename)
        conn.row_factory = sqlite3.Row
        return conn

    # Otherwise, create the database and its schema.
    # Specifically mention the non-integer fields that are not in the
    # "fields" dictionary:
    # - key: unique key ID for the row
    # - inserttimestamp: the timestamp at which the data was entered into the db
    # - timestamp: the timestamp of the data
    # - department: the Ricoh department ID
    # - name: the Ricoh username
    conn = sqlite3.connect(filename)
    conn.row_factory = sqlite3.Row
    c    = conn.cursor()
    sql  = 'CREATE TABLE IF NOT EXISTS printlog ('
    for sql_fieldname in fields:
        sql += f'{sql_fieldname} integer NOT NULL,'
    sql += '''Key integer primary key,
            InsertTimestamp default current_timestamp NOT NULL,
            Timestamp text NOT NULL,
            department text NOT NULL,
            name text NOT NULL,
            lastResetDate text NOT NULL)'''

    log.debug(f"Creating schema with SQL: {sql}")

    c.execute(sql)
    conn.commit()

    return conn


def main():
    args = setup_cli_args()
    log  = ECC.setup_logging(info=args.verbose,
                             debug=args.debug,
                             logfile=args.logfile, rotate=True,
                             slack_token_filename=args.slack_token_filename)

    conn = open_db(log, args.db)

    prev_data_rows = fetch_timestamp_data(log, conn, args.timestamp1)
    new_data_rows = fetch_timestamp_data(log, conn, args.timestamp2)

    prev_staffers = extract_data_to_compare(log, prev_data_rows, args.timestamp1)
    new_staffers = extract_data_to_compare(log, new_data_rows, args.timestamp2)

    printlog = compare_timestamps(log, new_staffers, prev_staffers)

    write_to_xlsx(log, printlog, args.xlsx, args.timestamp1, args.timestamp2)

    conn.close()

main()