#!/user/bin/env python3

# Script which runs daily to update staff print totals
# based on CSVs generated by the printer itself.

import os
import csv
import sqlite3
from sqlite3 import Error

import argparse
import datetime

# Find the path to the ECC module (by finding the root of the git
# tree).  This is robust, but it's a little clunky. :-\
try:
    import sys
    import subprocess
    out = subprocess.run(['git', 'rev-parse', '--show-toplevel'],
                         capture_output=True)
    dirname = out.stdout.decode('utf-8').strip()
    if not dirname:
        raise Exception("Could not find git root.  Are you outside the git tree?")

    moddir  = os.path.join(dirname, 'python')
    sys.path.insert(0, moddir)
    import ECC
except Exception as e:
    sys.stderr.write("=== ERROR: Could not find common ECC Python module directory\n")
    sys.stderr.write(f"{e}\n")
    exit(1)

###########################################################

def setup_cli_args():
    parser = argparse.ArgumentParser(description='Import Ricoh data into an SQLite3 database.')
    # TODO: use this to let the user choose the path to the output csv?
    #parser.add_argument('--csv',
    #                    required=True,
    #                    help='Path to CSV file containing Ricoh values to import to the database')
    parser.add_argument('--db',
                        required=True,
                        help='Path to sqlite database to import values from')
    parser.add_argument('--timestamp1', # TODO: is this a valid way to get the timestamps and is there a better way to name them
                        required=True,
                        help='First timestamp GMT "yyyy-mm-dd hh:mm:ss" to compare')
    parser.add_argument('--timestamp2',
                        required=True,
                        help='Second timestamp GMT "yyyy-mm-dd hh:mm:ss" to compare')

    parser.add_argument('--logfile',
                        default=None,
                        help='Optional output logfile')

    parser.add_argument('--slack-token-filename',
                        required=True,
                        help='File containing the Slack bot authorization token')

    parser.add_argument('--verbose',
                        default=False,
                        action='store_true',
                        help='Enable verbose output')
    parser.add_argument('--debug',
                        default=False,
                        action='store_true',
                        help='Enable extra debugging')

    args = parser.parse_args()

    return args

# returns a list of rows with with a timestamp matching the one passed to it
def fetch_timestamp_data(log, conn, timestamp):
    c = conn.cursor()

    timestamp_rows = list()

    c.execute('SELECT * FROM printlog WHERE timestamp=?', timestamp)
    timestamp_rows.append(c.fetchall()) # fetchall should return a list of rows matching the select statement

    log.debug(f"Found {len(timestamp_rows)} rows with timestamp {timestamp}")

    return timestamp_row


# returns a dictionary of staffers with their data
def extract_data_to_compare(log, rows, timestamp):

    def _extract_staffer(row):
        # TODO : determine whether the list returned by fetch_timestamp_data can be accessed like this
        return {
            'num'           : row['User'],
            'name'          : row['Name'],
            'total'         : int(row['Total Prints'],
            'b&wtotal'      : int(row['B & W(Total Prints)']),
            'colortotal'    : int(row['Color(Total Prints)']),
        }

    staffers = dict()

    # iterates through the list of rows, retrieves data about each staffer
    for row in rows:
        num = row['User']
        this_staffer = _extract_staffer(row)
        staffers[num] = this_staffer

    log.debug(f"Extracted {len(staffers)} staffers with timestamp {timestamp}")
    return staffers


# finds the deltas between the sets of data, returns a list of users' deltas
def compare_timestamps(log, new_data, old_data):

    updated_printlog = list()

    for num, row in new_data.items():
        if num in old_data:
            row_old = old_data[num]
            print_delta = row['total'] - row_old['total']
            print_black_delta = row['b&wtotal'] - row_old['b&wtotal']
            print_color_delta = row['colortotal'] - row_old['colortotal']
            updated_printlog.append({
                'User'                  : row['num'],
                'Name'                  : row['name'],
                'Total Prints'          : row['total'],
                'Prints Today'          : print_delta,
                'B & W Prints Total'    : row['b&wtotal'],
                'B & W Prints Today'    : print_black_delta,
                'Color Prints Total'    : row['colortotal'],
                'Color Prints Today'    : print_color_delta,
            })

    log.info(f'Compared {len(new_data)} staffers')
    return updated_printlog


# writes the new deltas to a csv titles printlog.csv
def write_printlogs(log, printlog):
    fieldnames = ['User', 'Name', 'Total Prints', 'Prints Today', 'B & W Prints Total', 'B & W Prints Today', 'Color Prints Total', 'Color Prints Today']
    filename = 'printlog.csv' #TODO: is this what we should name it?

    with open(filename, "w+", encoding="utf-8", newline='') as f:
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()

        #Write each staffer by User Number
        for staffer in printlog:
            writer.writerow(staffer)

    log.info(f"Wrote {filename} with {len(printlog)} data rows")

def open_db(log, filename):
    # If the database exists, just open and return it
    if os.path.exists(filename):
        return sqlite3.connect(filename)

    # Otherwise, create the database and its schema.
    # Specifically mention the non-integer fields that are not in the
    # "fields" dictionary:
    # - key: unique key ID for the row
    # - inserttimestamp: the timestamp at which the data was entered into the db
    # - timestamp: the timestamp of the data
    # - department: the Ricoh department ID
    # - name: the Ricoh username
    conn = sqlite3.connect(filename)
    c    = conn.cursor()
    sql  = 'CREATE TABLE IF NOT EXISTS printlog ('
    for sql_fieldname in fields:
        sql += f'{sql_fieldname} integer NOT NULL,'
    sql += '''Key integer primary key,
            InsertTimestamp default current_timestamp NOT NULL,
            Timestamp text NOT NULL,
            department text NOT NULL,
            name text NOT NULL,
            lastResetDate text NOT NULL)'''

    log.debug(f"Creating schema with SQL: {sql}")

    c.execute(sql)
    conn.commit()

    return conn

def main():
    args = setup_cli_args()
    log  = ECC.setup_logging(info=args.verbose,
                             debug=args.debug,
                             logfile=args.logfile, rotate=True,
                             slack_token_filename=args.slack_token_filename)

    conn = open_db(log, args.db)

    prev_data_rows = fetch_timestamp_data(log, conn, args.timestamp1) #TODO: name these variables better
    new_data_rows = fetch_timestamp_data(log, conn, args.timestamp2)

    prev_staffers = extract_data_to_compare(log, prev_data_rows, args.timestamp1)
    new_staffers = extract_data_to_compare(log, new_data_rows, args.timestamp2)

    printlog = compare_timestamps(log, new_staffers, prev_staffers)

    write_printlogs(log, printlog)

    conn.close()

main()